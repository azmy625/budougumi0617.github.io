<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rubyonrails on My External Storage</title>
    <link>https://budougumi0617.github.io/categories/rubyonrails/</link>
    <description>Recent content in Rubyonrails on My External Storage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Wed, 20 Sep 2017 08:52:42 +0900</lastBuildDate>
    <atom:link href="/categories/rubyonrails/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rspec内でテスト対象のControllerのメソッドの戻り値をスタブする</title>
      <link>https://budougumi0617.github.io/post/2017/09/20/rspec-access-controller/</link>
      <pubDate>Wed, 20 Sep 2017 08:52:42 +0900</pubDate>
      
      <guid>https://budougumi0617.github.io/post/2017/09/20/rspec-access-controller/</guid>
      <description>C#では対象インスタンスのメソッドの挙動を変えることは出来ないので、別の手段を探していたのだが、rubyでは出来た。
TL;DR  RSpec書いたControllerSpecの中でテスト対象のコントローラのメソッドの戻り値をモックオブジェクトに変えたかった。 ControllerExampleGroupで定義されているcontrollerからテスト中のコントローラインスタンスを操作することが可能  Module: RSpec::Rails::ControllerExampleGroup#controller
前提 rspec-rails (~&amp;gt; 3.0.0.beta2)で確認。
テスト対象のコントローラはこんな感じ。
class MyController &amp;lt; ApplicationController def my_client MyClient.new end end  controllerとallowでメソッドの戻り値をすげ替える allowを使えばメソッドの挙動をすげ替えることが出来る。Railsの場合はcontrollerを使えばテスト対象のコントローラのインスタンスを得られるので、テストを実行する前に下記の操作をしておくことで、テスト対象のメソッドの挙動も変更しておくことができる。下記の例は、doubleで作成したダミーオブジェクトで、MyController#my_clientの挙動を変更する例。例外を出す例も記載している。
# MyControllerのRSpecのdescribe内 # ダミーオブジェクト作成 my_client_mock = double(&#39;Dummy Client&#39;) # メソッドの振る舞いを設定しておく。 allow(my_client_mock).to receive(:my_method).and_return(&amp;quot;foo&amp;quot;) # テスト対象のコントローラのメソッドにダミーオブジェクトを設定 allow(controller).to receive(:my_client).and_return(my_client_mock) # 例外を出す場合 allow(controller).to receive(:my_client).and_raise(MyError.new(&#39;bar&#39;))  参考 Module: RSpec::Rails::ControllerExampleGroup#controller
Rspec3のexpectとallowの違い
RSpecまとめ(2)～Mock(double/stub/mock)～</description>
    </item>
    
    <item>
      <title>docker-compose上のRailsのデバッグを行う</title>
      <link>https://budougumi0617.github.io/post/2017/09/02/debug-rails-on-docker/</link>
      <pubDate>Sat, 02 Sep 2017 12:16:06 +0900</pubDate>
      
      <guid>https://budougumi0617.github.io/post/2017/09/02/debug-rails-on-docker/</guid>
      <description>Rails本の写経をdocer-composeで行なったときのTips。
TL;DR docke-composeで作ったRubyOnRailsコンテナでbinding.pryによるデバッグを行えるようにする。
前提 doker-composeでRails、Spring用のコンテナなど、複数コンテナを起動する形のRails環境を構築した。基本構成は以下の記事に習っている。
高速に開発できる Docker + Rails開発環境のテンプレートを作った
事前準備 Railsをデバッグ実行するために必要な設定ファイルの準備をする。
コンテナの標準入出力にアタッチするために、Dockerの設定をしておく。
docker-compose.yml
services: rails: &amp;amp;app_base tty: true stdin_open: true  ブレークポイントを貼るためのbinding.pryをするためのGemを追加する。 Gemfileはpry-railsの他にpry-byebugも追加しておくとステップ実行が出来る。
Gemfile
group :development, :test do gem &#39;pry-rails&#39; gem &#39;pry-byebug&#39; end  Railsプロジェクトのrootディレクトリに.pryrcファイルを配置しておけばデバッグ中に利用できるエイリアスが貼れる。（他のも色の設定とか出来るらしい）
.pryrc
if defined?(PryByebug) Pry.commands.alias_command &#39;c&#39;, &#39;continue&#39; Pry.commands.alias_command &#39;s&#39;, &#39;step&#39; Pry.commands.alias_command &#39;n&#39;, &#39;next&#39; Pry.commands.alias_command &#39;f&#39;, &#39;finish&#39; end  デバッグしたいメソッドにbinding.pryの記載をして、docker-compose upコマンドでRailsを起動して、該当メソッドが実行される操作を行う。 出力がこんな状態になればpryでデバッグが開始できる状態になっている。
rails_1 | From: /app/app/controllers/staff/customers_controller.rb @ line 4 Staff::CustomersController#index: rails_1 | rails_1 | 2: def index rails_1 | 3: binding.</description>
    </item>
    
  </channel>
</rss>
